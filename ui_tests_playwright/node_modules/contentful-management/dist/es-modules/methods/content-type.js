const _excluded = ["fieldId"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
/**
 * @private
 * @param id - unique ID of the field
 * @param key - the attribute on the field to change
 * @param value - the value to set the attribute to
 */
const findAndUpdateField = function findAndUpdateField(contentType, fieldId, omitOrDelete) {
  const field = contentType.fields.find(field => field.id === fieldId);
  if (!field) {
    return Promise.reject(new Error(`Tried to omitAndDeleteField on a nonexistent field, ${fieldId}, on the content type ${contentType.name}.`));
  }
  field[omitOrDelete] = true;
  return Promise.resolve(contentType);
};
export const omitAndDeleteField = (makeRequest, _ref, contentType) => {
  let fieldId = _ref.fieldId,
    params = _objectWithoutProperties(_ref, _excluded);
  return findAndUpdateField(contentType, fieldId, 'omitted').then(newContentType => {
    return makeRequest({
      entityType: 'ContentType',
      action: 'update',
      params,
      payload: newContentType
    });
  }).then(newContentType => {
    return findAndUpdateField(newContentType, fieldId, 'deleted');
  }).then(newContentType => {
    return makeRequest({
      entityType: 'ContentType',
      action: 'update',
      params,
      payload: newContentType
    });
  });
};